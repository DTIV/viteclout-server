pragma soliditypp ^0.4.2;

contract VuilderToken {
   mapping(address => mapping(address => uint)) VFTBalance;
   mapping(address => uint) ViteBalance;

   mapping(address => bool) isMinted;
   mapping(address => uint) circulatingSupply;

   onMessage mint() {
      require(isMinted[msg.sender] == false, "Already minted");
      VFTBalance[msg.sender][msg.sender] = 1000;
      isMinted[msg.sender] = true;
   }

   getter getBalance(address vuilderAddress, address inquirer) returns(uint) {
      return VFTBalance[vuilderAddress][inquirer];
   }
   
   getter getCirculatingSupply(address vuilderAddress) returns(uint) {
      return circulatingSupply[vuilderAddress]; 
   }

   onMessage sellToken(
      address vuilderAddress, 
      uint amount
   ) payable {
      require(VFTBalance[vuilderAddress][msg.sender] >= amount, "Insufficient tokens");

      VFTBalance[vuilderAddress][msg.sender] -= amount;
      VFTBalance[vuilderAddress][vuilderAddress] += amount;

      uint cost = getSellPrice(amount, vuilderAddress);

      ViteBalance[vuilderAddress] -= cost;
      msg.sender.transfer(msg.tokenid, cost);

      circulatingSupply[vuilderAddress] += amount;
   }

    onMessage buyToken(
      address vuilderAddress, 
      uint amount
   ) payable {
      require(VFTBalance[vuilderAddress][vuilderAddress] >= amount, "Insufficient tokens");

      uint cost = getBuyPrice(amount, vuilderAddress);

      require(cost == msg.amount, "Wrong amount of vite tokens sent");

      ViteBalance[vuilderAddress] += cost;

      VFTBalance[vuilderAddress][vuilderAddress] -= amount;
      VFTBalance[vuilderAddress][msg.sender] += amount;

      circulatingSupply[vuilderAddress] += amount;
   }

   function getSellPrice(uint amount, address vuilderAddress) private returns(uint) {
      uint newCirculatingSupply = circulatingSupply[vuilderAddress];
      newCirculatingSupply += amount;
      return  amount*(3 * (newCirculatingSupply)**2)/1000;
   }

   function getBuyPrice(uint amount, address vuilderAddress) private returns(uint) {
      uint newCirculatingSupply = circulatingSupply[vuilderAddress];
      newCirculatingSupply -= amount;
      return  amount*(3 * (newCirculatingSupply)**2)/1000;
   }
}