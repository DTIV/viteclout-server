pragma soliditypp ^0.4.2;

contract VuilderToken {
   mapping(address => mapping(address => uint)) balances;
   mapping(address => bool) isMinted;
   mapping(address => uint) circulatingSupply;

   onMessage mint() {
      require(isMinted[msg.sender] == false, "Already minted");
      balances[msg.sender][msg.sender] = 1000;
      isMinted[msg.sender] = true;
   }

   getter getBalance(address vuilderAddress, address inquirer) returns(uint) {
      return balances[vuilderAddress][inquirer];
   }
   
   getter getCirculatingSupply(address vuilderAddress) returns(uint) {
      return circulatingSupply[vuilderAddress]; 
   }

   onMessage sendToken(
      address vuilderAddress, 
      address receiverAddress,
      address senderAddress,
      uint amount
   ) payable {
      address senderAddresss = msg.sender;
      require(balances[vuilderAddress][senderAddresss] >= amount, "Insufficient tokens");

      bool isSenderVuilder = senderAddresss == vuilderAddress;
      bool isReceiverVuilder = vuilderAddress == receiverAddress;

      require(isSenderVuilder != isReceiverVuilder, "Invalid request");
      require(senderAddresss != receiverAddress, "Invalid request");

      uint cost = getCost(amount, vuilderAddress, receiverAddress, senderAddress)*amount;

      require(msg.amount == cost, "Insufficient funds");

      balances[vuilderAddress][senderAddresss] -= amount;
      balances[vuilderAddress][receiverAddress] += amount;

      if(isSenderVuilder) {
         circulatingSupply[vuilderAddress] += amount;
      } else if(isReceiverVuilder) {
         circulatingSupply[vuilderAddress] -= amount;
      }
   }

   getter _getCost(uint amount, address vuilderAddress, address receiverAddress, address senderAddress) returns(uint) {
      uint newCirculatingSupply = circulatingSupply[vuilderAddress];

      bool isSenderVuilder = senderAddress == vuilderAddress;
      bool isReceiverVuilder = vuilderAddress == receiverAddress;

      if(isSenderVuilder && !isReceiverVuilder) {
         newCirculatingSupply += amount;
      } else if(isReceiverVuilder && !isSenderVuilder) {
         newCirculatingSupply -= amount;
      }

      return  (3 * (newCirculatingSupply)**2)/1000;
   }

    function getCost(uint amount, address vuilderAddress, address receiverAddress, address senderAddress) private returns(uint) {
      uint newCirculatingSupply = circulatingSupply[vuilderAddress];

      bool isSenderVuilder = senderAddress == vuilderAddress;
      bool isReceiverVuilder = vuilderAddress == receiverAddress;

      if(isSenderVuilder && !isReceiverVuilder) {
         newCirculatingSupply += amount;
      } else if(isReceiverVuilder && !isSenderVuilder) {
         newCirculatingSupply -= amount;
      }

      return  amount*(3 * (newCirculatingSupply)**2)/1000;
   }
}